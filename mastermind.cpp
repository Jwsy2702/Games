#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <cmath>

void set_random_seed();
int randn(int n);
bool same_num_of_white_blacks(std::vector<int> attempt, const std::vector<int>& sequence, int black_hits, int white_hits);
void updating_black_and_white(std::vector<int> attempt, std::vector<int> sequence, int& black_hits, int& white_hits);

struct mm_code_maker{

    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
    }

    /// this member function generates a random sequence based
    /// on the length and num parameters stored as member data

    void generate_sequence(){
        for(int i = 0; i < length; i++){
            sequence.push_back(randn(num));
        }
    }

    void give_feedback(const std::vector<int>& attempt, int& black_hits, int& white_hits){
            /// takes in input an attempt
            /// and provides feedback in terms of black hits
            /// and white hits (see linked paper)
            std::cout << "black hits: " << '\n';
    				std::cin >> black_hits;
    				std::cout << "white hits" << '\n';
    				std::cin >> white_hits;
      }

    /// member data holding the sequence generated by generate_sequence
    std::vector<int> sequence;

    /// member data holding the values for length of code and number of symbols
    int length;
    int num;
};


/// this is the struct definition for the solver
struct mm_solver{

    /// this member function sets the values for the member data
    /// representing the lenght of the code
    /// and the number of symbols (the symbols will be 0 to i_num - 1)
    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
        possibilities = std::pow(num, length);
        //length <= 7 && num <= 11
        if (possibilities < 0 || possibilities > 20000000){
          digit_to_guess = 0;
          position_index = 0;
          answer_is_zero = false;
          attempttmp.assign(length, 0);
        }
        else if(possibilities == 1){
          for(int i=0; i < length; i++){
            tmp.push_back(0);
          }
          possible_values.push_back(tmp);
        }
        else{ //(possibilities < 20000000)
          for(int i = 0; i < length; i++){
            tmp.push_back(0);
          }
          possible_values.push_back(tmp);
          int total = std::pow(num, length);
          for(int i = 1; i < total; i++){
            attempt_in_order(tmp, length, num);
            possible_values.push_back(tmp);
          }
        }
    }

    /// this member function creates an attempt to find the right code
    void create_attempt(std::vector<int>& attempt){
        if(possibilities < 0 || possibilities > 20000000){
          if(answer_is_zero == true){
            attempttmp[position_index - 1] = 0;
            attempttmp[position_index] = digit_to_guess;
            answer_is_zero = false;
          }
          else{
            attempttmp[position_index] = digit_to_guess;
          }
          attempt = attempttmp;
        }
        else if(possibilities == 1){
          for(int i=0; i < length; i++){
            attempt.push_back(0);
          }
        }
//length <= 5 && num <= 7
        else if(possibilities < 120000){
          int total = std::pow(num, length);
          if(possible_values.size() == total){
            for(int i=0; i < length - 2; i++){
              attempt.push_back(0);
            }
            attempt.push_back(1);
            attempt.push_back(2);
          }
          else{
            int partition_counter = 0, tmp_partition_counter = 0, black_hits = 0, white_hits = 0;
            std::vector<bool> list((length+1)*(length+1), false);

            for(int i=0; i < possible_values.size(); i++){
              for(int j=0; j < possible_values.size(); j++){
                updating_black_and_white(possible_values[i], possible_values[j], black_hits, white_hits);
                list[black_hits*(length+1) + white_hits] = true;
              }

              tmp_partition_counter = 0;
              for(int k=0; k < list.size(); k++){
                if(list[k] == true){
                  tmp_partition_counter++;
                }
              }

              if(tmp_partition_counter > partition_counter){
                partition_counter = tmp_partition_counter;
                attempt = possible_values[i];
              }
            }
          }
        }

        //6 <= length <= 7 && num <= 11
        else{ //if(possibilities < 20000000)
          int total = std::pow(num, length);
          if(possible_values.size() == total){
            for(int i=0; i < length - 2; i++){
              attempt.push_back(0);
            }
            attempt.push_back(1);
            attempt.push_back(2);
          }
          else{
            attempt = possible_values[0];
          }
        }
    }

    /// this member function acquires the feedback about a certain attempt
    void learn(std::vector<int>& attempt, int black_hits, int white_hits){

        if (possibilities < 0 || possibilities > 20000000){
          if(position_index == 0 && digit_to_guess == 0 && answer_is_zero == false){
            prev_black_hits = black_hits;
          }
          if(black_hits == prev_black_hits){
            digit_to_guess++;
          }
          else if(black_hits > prev_black_hits){
            digit_to_guess = 1;
            position_index++;
          }
          else{ //black hits < previous black hits
            answer_is_zero = true;
            digit_to_guess = 1;
            position_index++;
          }
          if(!answer_is_zero){
            prev_black_hits = black_hits;
          }
        }
        //create a vector that is reduced from before based on
        else{ //(possibilities < 20000000)
          std::vector< std::vector<int> > new_possible_values;
          bool same_whites_and_blacks;
          for(int i = 0; i < possible_values.size(); i++){
            same_whites_and_blacks = same_num_of_white_blacks(possible_values[i], attempt, black_hits, white_hits);
            if(same_whites_and_blacks == true){
              new_possible_values.push_back(possible_values[i]);
            }
          }

          possible_values = new_possible_values;
        }
    }


    void attempt_in_order(std::vector<int>& next_attempt, int length, int num){
      bool carry = true;
      for(int position = length - 1; (position >= 0) && carry; position--){
        carry = false;
        next_attempt[position]++;
        if(next_attempt[position] == num){
          next_attempt[position] = 0;
          carry = true;
        }
      }
    }


    std::vector< std::vector<int> > possible_values;
    std::vector<int> tmp;



    int length;
    int num;
    int possibilities;
    int digit_to_guess;
    int position_index;
    int prev_black_hits;
    bool answer_is_zero;
    std::vector<int> attempttmp;

};


int main(){
    set_random_seed();

    float length, num, total_game = 5, total_attempt = 0;
    float average;
    std::cout << "enter length of sequence and number of possible values:" << std::endl;
    std::cin >> length >> num;

    for(int k=0; k < total_game; k++){
      mm_solver solver;
      solver.init(length, num);
      mm_code_maker maker;
      maker.init(length, num);\
      std::cout << "generate_sequence" << '\n';
      std::cout << "the sequence generated by the code maker was:" << std::endl;
      for(int i = 0; i < maker.sequence.size(); i++){
          std::cout << maker.sequence[i] << " ";
      }
      std::cout << std::endl;
      int black_hits=0, white_hits=0;
      int attempts_limit = 20;
      int attempts = 0;
      while((black_hits < length) && (attempts < attempts_limit)){
          std::vector<int> attempt;
          solver.create_attempt(attempt);
          std::cout << "attempt number " << attempts << " : " <<std::endl;
          for(int i = 0; i < attempt.size(); i++){
              std::cout << attempt[i] << " ";
          }
          std::cout << std::endl;
					maker.give_feedback(attempt, black_hits, white_hits);
          std::cout << "black pegs: " << black_hits << " " << " white pegs: " << white_hits << std::endl;
          solver.learn(attempt, black_hits, white_hits);
          attempts++;
      }

      if(black_hits == length){
          std::cout << "the solver has found the sequence in " << attempts << " attempts" << std::endl;
          total_attempt = total_attempt+attempts;
      }
      else{
          std::cout << "after " << attempts << " attempts still no solution" << std::endl;
      }
    }
    average = total_attempt/total_game;
    std::cout << "average is " << average << '\n';
    return 0;
}


void set_random_seed(){
    std::srand(std::time(0));
}

int randn(int n){
    return std::rand() % n;
}

bool same_num_of_white_blacks(std::vector<int> attempt, const std::vector<int>& sequence, int black_hits, int white_hits){
    std::vector<int> seqtmp = sequence, attmp = attempt;
    int new_black_hits = 0;
    int new_white_hits = 0;

    for(int i=0; i < attempt.size(); i++){
      if(attempt[i] == sequence[i]){
        new_black_hits++;
        seqtmp[i] = -1; //indicate not to use this
        attmp[i] = -2;
      }
    }

    for(int i=0; i < attempt.size(); i++){
      for(int j=0; j < attempt.size(); j++){
        if(attmp[i] == seqtmp[j]){
          new_white_hits++;
          seqtmp[j] = -1;
          attmp[i] = -2;
        }
      }
    }

    if ((new_black_hits == black_hits) && (new_white_hits == white_hits)){
      return true;
    }
    else{
      return false;
    }
}

void updating_black_and_white(std::vector<int> attempt, std::vector<int> sequence, int& black_hits, int& white_hits){
    std::vector<int> seqtmp = sequence, attmp = attempt;
    black_hits = 0;
    white_hits = 0;

    for(int i=0; i < attempt.size(); i++){
      if(attempt[i] == sequence[i]){
        black_hits++;
        seqtmp[i] = -1; //indicate not to use this
        attmp[i] = -2;
      }
    }

    for(int i=0; i < attempt.size(); i++){
      for(int j=0; j < attempt.size(); j++){
        if(attmp[i] == seqtmp[j]){
          white_hits++;
          seqtmp[j] = -1;
          attmp[i] = -2;
        }
      }
    }
}
